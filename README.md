# Traffic-Signal-Management-with-Thread-Synchronization-

In this project I have Modelled a common roadway occurrence, where one lane is closed and a flag person is directing traffic. 
On one side of the road there is some construction work is going on so all the vehicles coming from north and south direction has 
to synchronise such that they pass through the construction area without any traffic jam or accident.                                                                       
This simulation utilises synchronisation mechanisms like mutexes, condition variables, and semaphores to coordinate threads efficiently. 
It prevents potential race conditions by safeguarding shared data structures with mutexes and ensures proper car generation through a 
semaphore-based mechanism. In this project we have  also employed a condition variable to manage the flag person's state and utilises proper 
sleep functions for delay. So basically The project's strengths lie in its effective synchronisation implementation, ensuring thread safety, 
controlled car production, and flag person coordination. Overall, the project showcases a valuable application of synchronisation techniques in a 
real-world traffic management scenario.

**Semaphore: Semaphore_Car**
This semaphore is used to control the access to the car production threads. It ensures that only one car production thread can generate cars at a time. It is waited upon using sem_wait and released using sem_post.

**Mutex lock: TrafficPolice_mutex_lock**
This mutex is used to protect critical sections of code where shared variables and data structures are accessed or modified. It is locked and unlocked using pthread_mutex_lock and pthread_mutex_unlock functions, respectively.

**Condition Variables: TrafficPolice_Condn** 
This condition variable is used to synchronise the flag person thread and the car production threads. It allows the flag person to sleep when there are no cars in both the nReadyQ and sReadyQ queues and wake up when signalled by the car production threads. It is waited upon using pthread_cond_wait and signalled using pthread_cond_signal.

**Queues: EastBuffer and WestBuffer**
These queues store the cars generated by the car production threads. Access to these queues is protected by the flagPersonMutex. The car consumer thread removes cars from the queues when processing them.
